{
  "contents": [
    {
      "ContentID": 55,
      "ContentType": "Document",
      "Content": "### When a subgraph is published to The Graph Network, you can visit its subgraph details page on [Graph Explorer](https://thegraph.com/explorer) and use the \"Playground\" tab to explore the deployed GraphQL API for the subgraph, issuing queries and viewing the schema.\n\n###\n\n> Each subgraph published to The Graph Network has a unique query URL in Graph Explorer for making direct queries that you can find by navigating to the subgraph details page and clicking on the \"Query\" button on the top right corner.\n\nLearn more about querying from an application [here](https://thegraph.com/docs/en/querying/querying-from-an-application/).\n\nAs you can notice, this query URL must use a unique API key. You can create and manage your API keys in [Subgraph Studio](https://thegraph.com/studio), in the \"API Keys\" section. Learn more about how to use Subgraph Studio [here](https://thegraph.com/docs/en/deploying/subgraph-studio/).\n\nSubgraph Studio users start on a Free Plan, which allows them to make 100,000 queries per month. Additional queries are available on the Growth Plan, which offers usage based pricing for additional queries, payable by credit card, or GRT on Arbitrum. You can learn more about billing [here](https://thegraph.com/docs/en/billing/).",
      "ContentCoverImage": null,
      "CreatedOn": "2024-09-18T18:33:15.758Z",
      "CreatedBy": "",
      "UpdatedOn": "2024-09-18T18:49:45.830Z",
      "UpdatedBy": "",
      "ApproximateReadTime": 4,
      "Author": "",
      "Title": "Querying The Graph",
      "ParentContentID": null,
      "RelatedContentIDs": []
    },
    {
      "ContentID": 56,
      "ContentType": "Document",
      "Content": "Regardless of whether you’re a dapp developer or a subgraph developer, you’ll need to manage your API keys. This is important for you to be able to query subgraphs because API keys make sure the connections between application services are valid and authorized. This includes authenticating the end user and the device using the application.\n\nThe \"API keys\" table lists out existing API keys, which will give you the ability to manage or delete them. For each key, you can see its status, the cost for the current period, the spending limit for the current period, as well as total query numbers. You can click the \"three dots\" menu to edit a given API key:\n\n* Rename API key\n* Regenerate API key\n* Delete API key\n* Manage spending limit: this is an optional monthly spending limit for a given API key, in USD. This limit is per billing period (calendar month).\n\nYou can click on an individual API key to view the Details page:\n\n1. The **Overview** section will allow you to:\n   * Edit your key name\n   * Regenerate API keys\n   * View the current usage of the API key with stats:\n     * Number of queries\n     * Amount of GRT spent\n2. Under **Security**, you’ll be able to opt into security settings depending on the level of control you’d like to have over your API keys. In this section, you can:\n   * View and manage the domain names authorized to use your API key\n   * Assign subgraphs that can be queried with your API key",
      "ContentCoverImage": null,
      "CreatedOn": "2024-09-18T18:36:20.491Z",
      "CreatedBy": "",
      "UpdatedOn": "2024-09-18T18:49:45.830Z",
      "UpdatedBy": "",
      "ApproximateReadTime": 2,
      "Author": "",
      "Title": "Managing API key",
      "ParentContentID": 55,
      "RelatedContentIDs": []
    },
    {
      "ContentID": 57,
      "ContentType": "Document",
      "Content": "The Graph provides a decentralized way to query data from blockchains.\n\nThe Graph network's data is exposed through a GraphQL API, making it easier to query data with the GraphQL language.\n\nThis page will guide you through the essential GraphQL language rules and GraphQL queries best practices.\n\n***\n\n## Querying a GraphQL API\n\n⁠[#Link to this section](https://thegraph.com/docs/en/querying/querying-best-practices/#querying-a-graphql-api)\n\n### The anatomy of a GraphQL query\n\n⁠[#Link to this section](https://thegraph.com/docs/en/querying/querying-best-practices/#the-anatomy-of-a-graphql-query)\n\nUnlike REST API, a GraphQL API is built upon a Schema that defines which queries can be performed.\n\nFor example, a query to get a token using the `token` query will look as follows:\n\n\n\n```txt\nquery GetToken($id: ID!) {\n  token(id: $id) {\n    id\n    owner\n  }\n}\n```\n\nwhich will return the following predictable JSON response (*when passing the proper* `$id` *variable value*):\n\n\n\n```txt\n{\n  \"token\": {\n    \"id\": \"...\",\n    \"owner\": \"...\"\n  }\n}\n```\n\nGraphQL queries use the GraphQL language, which is defined upon [a specification](https://spec.graphql.org/).\n\nThe above `GetToken` query is composed of multiple language parts (replaced below with `[...]` placeholders):\n\n\n\n```txt\nquery [operationName]([variableName]: [variableType]) {\n  [queryName]([argumentName]: [variableName]) {\n    # \"{ ... }\" express a Selection-Set, we are querying fields from `queryName`.\n    [field]\n    [field]\n  }\n}\n```\n\nWhile the list of syntactic do's and don'ts is long, here are the essential rules to keep in mind when it comes to writing GraphQL queries:\n\n* Each `queryName` must only be used once per operation.\n* Each `field` must be used only once in a selection (we cannot query `id` twice under `token`)\n* Some `field`s or queries (like `tokens`) return complex types that require a selection of sub-field. Not providing a selection when expected (or providing one when not expected - for example, on `id`) will raise an error. To know a field type, please refer to [Graph Explorer](https://thegraph.com/docs/en/network/explorer/).\n* Any variable assigned to an argument must match its type.\n* In a given list of variables, each of them must be unique.\n* All defined variables must be used.\n\nFailing to follow the above rules will end with an error from the Graph API.\n\nFor a complete list of rules with code examples, please look at our [GraphQL Validations guide](https://thegraph.com/docs/en/release-notes/graphql-validations-migration-guide/).\n\n### Sending a query to a GraphQL API\n\n⁠[#Link to this section](https://thegraph.com/docs/en/querying/querying-best-practices/#sending-a-query-to-a-graphql-api)\n\nGraphQL is a language and set of conventions that transport over HTTP.\n\nIt means that you can query a GraphQL API using standard `fetch` (natively or via `@whatwg-node/fetch` or `isomorphic-fetch`).\n\nHowever, as stated in [\"Querying from an Application\"](https://thegraph.com/docs/en/querying/querying-from-an-application/), we recommend you to use our `graph-client` that supports unique features such as:\n\n* Cross-chain Subgraph Handling: Querying from multiple subgraphs in a single query\n* [Automatic Block Tracking](https://github.com/graphprotocol/graph-client/blob/main/packages/block-tracking/README.md)\n* [Automatic Pagination](https://github.com/graphprotocol/graph-client/blob/main/packages/auto-pagination/README.md)\n* Fully typed result\n\nHere's how to query The Graph with `graph-client`:\n\n\n\n```txt\nimport { execute } from '../.graphclient'\n\nconst query = `\nquery GetToken($id: ID!) {\n  token(id: $id) {\n    id\n    owner\n  }\n}\n`\nconst variables = { id: '1' }\n\nasync function main() {\n  const result = await execute(query, variables)\n  // `result` is fully typed!\n  console.log(result)\n}\n\nmain()\n```",
      "ContentCoverImage": null,
      "CreatedOn": "2024-09-18T18:40:54.376Z",
      "CreatedBy": "",
      "UpdatedOn": "2024-09-18T18:49:45.830Z",
      "UpdatedBy": "",
      "ApproximateReadTime": 3,
      "Author": "",
      "Title": "Querying",
      "ParentContentID": 55,
      "RelatedContentIDs": []
    },
    {
      "ContentID": 58,
      "ContentType": "Document",
      "Content": "The Graph is a protocol implemented as a distributed system.\n\nConnections fail. Requests arrive out of order. Different computers with out-of-sync clocks and states process related requests. Servers restart. Re-orgs happen between requests. These problems are inherent to all distributed systems but are exacerbated in systems operating at a global scale.\n\nConsider this example of what may occur if a client polls an Indexer for the latest data during a re-org.\n\n1. Indexer ingests block 8\n2. Request served to the client for block 8\n3. Indexer ingests block 9\n4. Indexer ingests block 10A\n5. Request served to the client for block 10A\n6. Indexer detects reorg to 10B and rolls back 10A\n7. Request served to the client for block 9\n8. Indexer ingests block 10B\n9. Indexer ingests block 11\n10. Request served to the client for block 11\n\nFrom the point of view of the Indexer, things are progressing forward logically. Time is moving forward, though we did have to roll back an uncle block and play the block under consensus forward on top of it. Along the way, the Indexer serves requests using the latest state it knows about at that time.\n\nFrom the point of view of the client, however, things appear chaotic. The client observes that the responses were for blocks 8, 10, 9, and 11 in that order. We call this the \"block wobble\" problem. When a client experiences block wobble, data may appear to contradict itself over time. The situation worsens when we consider that Indexers do not all ingest the latest blocks simultaneously, and your requests may be routed to multiple Indexers.\n\nIt is the responsibility of the client and server to work together to provide consistent data to the user. Different approaches must be used depending on the desired consistency as there is no one right program for every problem.\n\nReasoning through the implications of distributed systems is hard, but the fix may not be! We've established APIs and patterns to help you navigate some common use-cases. The following examples illustrate those patterns but still elide details required by production code (like error handling and cancellation) to not obfuscate the main ideas.",
      "ContentCoverImage": null,
      "CreatedOn": "2024-09-18T18:41:35.962Z",
      "CreatedBy": "",
      "UpdatedOn": "2024-09-18T18:49:45.830Z",
      "UpdatedBy": "",
      "ApproximateReadTime": 3,
      "Author": "",
      "Title": "Distributed Systems",
      "ParentContentID": 56,
      "RelatedContentIDs": []
    },
    {
      "ContentID": 59,
      "ContentType": "Document",
      "Content": "The Graph provides the `block: { number_gte: $minBlock }` API, which ensures that the response is for a single block equal or higher to `$minBlock`. If the request is made to a `graph-node` instance and the min block is not yet synced, `graph-node` will return an error. If `graph-node` has synced min block, it will run the response for the latest block. If the request is made to an Edge & Node Gateway, the Gateway will filter out any Indexers that have not yet synced min block and make the request for the latest block the Indexer has synced.\n\nWe can use `number_gte` to ensure that time never travels backward when polling for data in a loop. Here is an example:\n\n\n\n```txt\n/// Updates the protocol.paused variable to the latest\n/// known value in a loop by fetching it using The Graph.\nasync function updateProtocolPaused() {\n  // It's ok to start with minBlock at 0. The query will be served\n  // using the latest block available. Setting minBlock to 0 is the\n  // same as leaving out that argument.\n  let minBlock = 0\n\n  for (;;) {\n    // Schedule a promise that will be ready once\n    // the next Ethereum block will likely be available.\n    const nextBlock = new Promise((f) => {\n      setTimeout(f, 14000)\n    })\n\n    const query = `\n        query GetProtocol($minBlock: Int!) {\n            protocol(block: { number_gte: $minBlock }  id: \"0\") {\n              paused\n            }\n            _meta {\n                block {\n                    number\n                }\n            }\n        }`\n\n    const variables = { minBlock }\n    const response = await graphql(query, variables)\n    minBlock = response._meta.block.number\n\n    // TODO: Do something with the response data here instead of logging it.\n    console.log(response.protocol.paused)\n\n    // Sleep to wait for the next block\n    await nextBlock\n  }\n}\n```",
      "ContentCoverImage": null,
      "CreatedOn": "2024-09-18T18:42:41.236Z",
      "CreatedBy": "",
      "UpdatedOn": "2024-09-18T18:49:45.830Z",
      "UpdatedBy": "",
      "ApproximateReadTime": 4,
      "Author": "",
      "Title": "Polling data⁠",
      "ParentContentID": null,
      "RelatedContentIDs": []
    },
    {
      "ContentID": 60,
      "ContentType": "Document",
      "Content": "Graph Node is the component which indexes subgraphs, and makes the resulting data available to query via a GraphQL API. As such it is central to the indexer stack, and correct operation of Graph Node is crucial to running a successful indexer.\n\nThis provides a contextual overview of Graph Node, and some of the more advanced options available to indexers. Detailed documentation and instructions can be found in the [Graph Node repository](https://github.com/graphprotocol/graph-node).\n\n## Graph Node\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#graph-node)\n\n[Graph Node](https://github.com/graphprotocol/graph-node) is the reference implementation for indexing Subgraphs on The Graph Network, connecting to blockchain clients, indexing subgraphs and making indexed data available to query.\n\nGraph Node (and the whole indexer stack) can be run on bare metal, or in a cloud environment. This flexibility of the central indexing component is crucial to the robustness of The Graph Protocol. Similarly, Graph Node can be [built from source](https://github.com/graphprotocol/graph-node), or indexers can use one of the [provided Docker Images](https://hub.docker.com/r/graphprotocol/graph-node).\n\n### PostgreSQL database\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#postgresql-database)\n\nThe main store for the Graph Node, this is where subgraph data is stored, as well as metadata about subgraphs, and subgraph-agnostic network data such as the block cache, and eth\\_call cache.\n\n### Network clients\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#network-clients)\n\nIn order to index a network, Graph Node needs access to a network client via an EVM-compatible JSON-RPC API. This RPC may connect to a single client or it could be a more complex setup that load balances across multiple.\n\nWhile some subgraphs may just require a full node, some may have indexing features which require additional RPC functionality. Specifically subgraphs which make `eth_calls` as part of indexing will require an archive node which supports [EIP-1898](https://eips.ethereum.org/EIPS/eip-1898), and subgraphs with `callHandlers`, or `blockHandlers` with a `call` filter, require `trace_filter` support ([see trace module documentation here](https://openethereum.github.io/JSONRPC-trace-module)).\n\n**Network Firehoses** - a Firehose is a gRPC service providing an ordered, yet fork-aware, stream of blocks, developed by The Graph's core developers to better support performant indexing at scale. This is not currently an Indexer requirement, but Indexers are encouraged to familiarise themselves with the technology, ahead of full network support. Learn more about the Firehose [here](https://firehose.streamingfast.io/).\n\n### IPFS Nodes\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#ipfs-nodes)\n\nSubgraph deployment metadata is stored on the IPFS network. The Graph Node primarily accesses the IPFS node during subgraph deployment to fetch the subgraph manifest and all linked files. Network indexers do not need to host their own IPFS node. An IPFS node for the network is hosted at [https://ipfs.network.thegraph.com](https://ipfs.network.thegraph.com/).\n\n### Prometheus metrics server\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#prometheus-metrics-server)\n\nTo enable monitoring and reporting, Graph Node can optionally log metrics to a Prometheus metrics server.\n\n### Getting started from source\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#getting-started-from-source)\n\n#### Install prerequisites\n\n⁠[#Link to this section](https://thegraph.com/docs/en/operating-graph-node/#install-prerequisites)\n\n* **Rust**\n* **PostgreSQL**\n* **IPFS**\n* **Additional Requirements for Ubuntu users** - To run a Graph Node on Ubuntu a few additional packages may be needed.",
      "ContentCoverImage": null,
      "CreatedOn": "2024-09-18T18:44:42.069Z",
      "CreatedBy": "",
      "UpdatedOn": "2024-09-18T18:49:45.830Z",
      "UpdatedBy": "",
      "ApproximateReadTime": 4,
      "Author": "",
      "Title": "Operating Graph",
      "ParentContentID": 59,
      "RelatedContentIDs": []
    }
  ]
}
